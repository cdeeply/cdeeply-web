<!DOCTYPE html>
<html>
<head>

	<title>NN trained on ##N## ##D##</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<script type="text/javascript">
	
##NN data##
	const canCheckPrediction = ((typeof trainingInputs != 'undefined') && (typeof trainingOutputs != 'undefined'));
	const trainingFileName = "##N##";
	var numIOs, fName, displayFileName = "", dataWarning = false, wrapTo = 0;
	var language, precision, precisionIdx, showInputs, writeHeaders, Ctype, separator=",";
	var numSamples, whichAction, rowcol, tableNote, outputAsString, NNpredictor, costEstimator;
	var percentTrainingError = 0, percentTestError = -1, NNerrPrecision = 0, NNerr;
	
	var tableNums = [];
	var NNinputs = [], NNoutputs = [], NNvariationalInputs = [], trueOutputs = [], rowHeaders = [], colHeaders = [];
	var headersToWrite = [];
	
	const fileSuffix = {  C:"c", Java:"java", JS:"js", MAT:"m", Py:"py", R:"r"  };
	const lineBreak = {  C:"", Java:"", JS:"", MAT:"...", Py:"", R:""  };
	const Ctypes = [ "float", "double" ];
	const rowcolNames = [ "row", "column" ];
	const tab1 = "    ";
	const doExample = (testData.length > 0);
	
	function grand()  {  return Math.sqrt(-2.*Math.log(1.-Math.random())) * Math.cos(2.*Math.PI*Math.random());  }
	
	
	function arrayStr(arr, printPrecision, arrayWidth, rowSeparator, initFromLeft, nextLineIndent, lineBreakChar, appendF)
	{
		var cv, rtrn, charFromLeft, charsToAdd;
		
		function toMaxPrecision(num)  {
			if (printPrecision == 0)  return num;
			else  numStr = num.toPrecision(printPrecision)
				.replace(/\.0+(e|E|$)/, "$1")
				.replace(/\.([0-9]*)([1-9])0+(e|E|$)/, ".$1$2$3");
			if (appendF)  numStr += "f";
			return numStr;
		}
		
		if (arr.length == 0)  rtrn = "";
		else  {
			if (arrayWidth == 0)  arrayWidth = arr.length;
			rtrn = toMaxPrecision(arr[0]);
			charFromLeft = initFromLeft;
			for (cv = 1; cv < arr.length; cv++)  {
				if ((wrapTo > 0) && (charFromLeft >= wrapTo) && (cv < arr.length-1))  {
					if (cv % arrayWidth == 0)  rtrn += rowSeparator + lineBreakChar + "\n";
					else  rtrn += separator + lineBreakChar + "\n";
					toAdd = nextLineIndent + toMaxPrecision(arr[cv]);
					rtrn += toAdd;
					charFromLeft = toAdd.length;		}
				else  {
					if (cv % arrayWidth == 0)  charsToAdd = rowSeparator + toMaxPrecision(arr[cv]);
					else  charsToAdd = separator + toMaxPrecision(arr[cv]);
					rtrn += charsToAdd;
					charFromLeft += charsToAdd.length;
		}	}	}
		
		return rtrn;
	}
	
	
	function NNcode(NNlanguage, NNprecision, writeFunctionDef)
	{
		var cl, cil, cAF, swIdx;
		const tab2 = tab1+tab1, tab3 = tab2+tab1, tab4 = tab3+tab1;
		
		const varInputStr = {
			C:  function()  {  return Ctype + " *";  },
			Java:  function()  {  return Ctype + "[] ";  },
			JS:  function()  {  return "";  },
			MAT:  function()  {  return "";  },
			Py:  function()  {  return "";  },
			R:  function()  {  return "";  }
		}
		
		const AFnames = {
			C:  [ "", "doBinary", "doReLU", "doReLU1", "doSigmoid", "doTanh" ],
			Java:  [ "", "doBinary", "doReLU", "doReLU1", "doSigmoid", "doTanh" ],
			JS:  [ "", "doBinary", "doReLU", "doReLU1", "doSigmoid", "doTanh" ],
			MAT:  [ "", "doBinary", "doReLU", "doReLU1", "doSigmoid", "tanh" ],
			Py:  [ "", "doBinary", "doReLU", "doReLU1", "doSigmoid", "np.tanh" ],
			R:  [ "", "doBinary", "doReLU", "doReLU1", "doSigmoid", "tanh" ]
		}
		
		const AFfunctions = {
			C:  function(AF)  {
				const AFdefs = [ "", "{  if (l[i] <= 0.)  l[i] = 0.;  else  l[i] = 1.;  }", "if (l[i] <= 0.)  l[i] 0.;",
							"{  if (l[i] <= 0.)  l[i] = 0.;  else if (l[i] >= 1.)  l[i] = 1.;  }",
							 "l[i] = 1. / (1. + exp(-l[i]));", "l[i] = tanh(l[i]);" ];
				return "void " + AFnames["C"][AF] +
							"(" + Ctype + " *l, const int n)  {  int i;  for (i = 0; i < n; i++)  " + AFdefs[AF] + "  }\n\n";		},
			Java:  function(AF)  {
				const AFdefs = [ "", "{  if (l[i] <= 0.)  l[i] = 0.;  else  l[i] = 1.;  }", "if (l[i] <= 0.)  l[i] 0.;",
							"{  if (l[i] <= 0.)  l[i] = 0.;  else if (l[i] >= 1.)  l[i] = 1.;  }",
							 "l[i] = 1. / (1. + Math.exp(-l[i]));", "l[i] = Math.tanh(l[i]);" ];
				return tab1 + "private void " + AFnames["Java"][AF] + "(" + Ctype +
							"[] l)  {  int i;  for (i = 0; i < l.length; i++)  " + AFdefs[AF] + "  }\n\n";		},
			JS:  function(AF)  {
				const AFdefs = [ "", "{  if (l[i] <= 0.)  l[i] = 0.;  else  l[i] = 1.;  }", "if (l[i] <= 0.)  l[i] 0.;",
							"{  if (l[i] <= 0.)  l[i] = 0.;  else if (l[i] >= 1.)  l[i] = 1.;  }",
							 "l[i] = 1. / (1. + Math.exp(-l[i]));", "l[i] = Math.tanh(l[i]);" ];
				return tab1 + "function " + AFnames["JS"][AF] +
							"(l)  {  for (var i = 0; i < l.length; i++)  " + AFdefs[AF] + "  }\n\n";		},
			MAT:  function(AF)  {
				const AFdefs = [ "", "max(0, min(1, ceil(l)))", "max(0, l)", "max(0, min(1, l))", "1. ./ (1. + exp(-l))", "" ];
				if (AFdefs[AF] == "")  return "";
				return tab2 + AFnames["MAT"][AF] + " = @(l) " + AFdefs[AF] + ";\n\n";		},
			Py:  function(AF)  {
				const AFdefs = [ "", "max(0, min(1, np.ceil(l[i])))", "max(0, l[i])", "max(0, min(1, l[i]))",
							 "1. / (1. + np.exp(-l[i]))", "" ];
				if (AFdefs[AF] == "")  return "";
				return tab2 + "def " + AFnames["Py"][AF] + "(l):\n" + tab3 +
							"for i in range(len(l)):\n" + tab4 + "l[i] = " + AFdefs[AF] + "\n" + tab2 + "\n";		},
			R:  function(AF)  {
				const AFdefs = [ "", "max(0, min(1, ceiling(l[i])))", "max(0, l[i])", "max(0, min(1, l[i]))",
							 "1. / (1. + exp(-l[i]))", "" ];
				if (AFdefs[AF] == "")  return "";
				return tab1 + AFnames["R"][AF] + " <- function(l)\n" + tab1 + "{\n" + tab2 + "for (i in 1:length(l))  {\n"
							+ tab3 + "l[i] = " + AFdefs[AF] + "\n" + tab2 + "}\n" + tab2 + "return(l)\n" + tab1 + "}\n\n";		}
		}
		
		const initLayerDef = {
			
			C:  function()  {
					var lInitFunctions = "";
					if ((!hasBias) || (sparseWeights))  lInitFunctions = "void clearLayer(" + Ctype + " *l, const int n)  {" +
						"  memset(l, 0, n*sizeof(" + Ctype + "));  }\n\n";
					if (hasBias)  {
						if (!sparseWeights)  lInitFunctions = "void setLayer(" + Ctype + " *l, const " + Ctype + " *b, const int n)  {" +
							"  memcpy(l, b, n*sizeof(" + Ctype + "));  }\n\n";
						else  lInitFunctions += "void setLayer(" + Ctype + " *l, const int *bi, const " + Ctype + " *b, const int n, const int nb)\n{\n" +
							"    int i;\n\n    memset(l, 0, n*sizeof(" + Ctype + "));\n" +
							"    for (i = 0; i < nb; i++)  l[bi[i]] = b[i];\n}\n\n";		}
					return lInitFunctions;			},
			
			Java:  function()  {
					var lInitFunctions = "";
					if ((!hasBias) || (sparseWeights))  lInitFunctions = "private void clearLayer(" + Ctype + "[] l)  {  Arrays.fill(l, 0);  }\n\n";
					if (hasBias)  {
						if (!sparseWeights)  lInitFunctions = "private void setLayer(" + Ctype + "[] l, " + Ctype +
							"[] b)  {  System.arraycopy(b, 0, l, 0, l.length);  }\n\n";
						else  lInitFunctions += "private void setLayer(" + Ctype + "[] l, int[] bi, " + Ctype + "[] b)\n" + tab1 + "{\n" +
							tab2 + "int i;\n" + tab2 + "Arrays.fill(l, 0);\n" + tab2 +
							"for (i = 0; i < b.length; i++)  l[bi[i]] = b[i];\n" + tab1 + "}\n\n";		}
						return lInitFunctions;			},
			
			JS:  function()  {
					var lInitFunctions = "";
					if ((!hasBias) || (sparseWeights))  lInitFunctions = "function clearLayer(l)  {  for (var i = 0; i < l.length; i++)  l[i] = 0;  }\n\n";
					if (hasBias)  {
						if (!sparseWeights)  lInitFunctions = "function setLayer(l, b)  {  for (var i = 0; i < l.length; i++)  l[i] = b[i];  }\n\n";
						else  lInitFunctions += "function setLayer(l, bi, b)\n" + tab1 + "{\n" + tab2 +
								"for (var i = 0; i < l.length; i++)  l[i] = 0;\n" + tab2 +
								"for (var i = 0; i < b.length; i++)  l[bi[i]] = b[i];\n" + tab1 + "}\n\n";		}
					return lInitFunctions;			},
			
			MAT:  function()  {  return "";  },
			Py:  function()  {  return "";  },
			R:  function()  {  return "";  }
		}
		
		const headers = {
			
			C:  function(dummy, initLayerStr, varInsDef, fDefs)  {
					var a2lStr;
					if (sparseWeights)  {
						a2lStr = "void addToLayer(" + Ctype + " *l, const " + Ctype + " *l0, " +
									"const int *wi0, const int *wif, const " + Ctype + " *w, const int nw)\n{\n" +
							"    int i;\n\n" +
							"    for (i = 0; i < nw; i++)  {\n" +
							"        l[wif[i]] += w[i] * l0[wi0[i]];\n" +
							"    }\n}\n\n";
					}
					else  {
						a2lStr = "void addToLayer(" + Ctype + " *l, const int n, const " + Ctype + " *l0, " +
									"const int n_0, const " + Ctype + " *w)\n{\n" +
							"    int i, i0;\n\n" +
							"    for (i = 0; i < n; i++)  {\n" +
							"    for (i0 = 0; i0 < n_0; i0++)  {\n" +
							"        l[i] += (*w) * l0[i0];\n" +
							"        w++;\n    }}\n}\n\n";
					}
					return "#include <math.h>\n" + "#include <string.h>\n\n" +
						initLayerStr + a2lStr + fDefs + "\n" +
						tab1 + "// NN trained on " + trainingFileName + "\n" +
						tab1 + "// usage:  NNpredict(" + Ctype + " inputs[" + layerSize[1] + "], " +
								Ctype + " outputs[" + numOutputs + "]) -- processes a single sample\n\n" +
						"void NNpredict(" + Ctype + " *ins" + varInsDef + ", " + Ctype + " *outs)\n{\n";  },
			
			Java:  function(dummy, d2, d3, fDefs)  {
					return "import java.lang.Math;\nimport java.lang.System;\nimport java.util.Arrays;\n\n" +
						tab1 + "// class 'myNN' trained on " + trainingFileName + "\n" +
						tab1 + "// usage:  NNpredict(" + Ctype + "[" + layerSize[1] + "] inputs, " +
								Ctype + "[" + numOutputs + "] outputs) -- processes a single sample\n\n" +
						"public class myNN\n{\n";  },
			
			JS:  function(writeFunctionDef, d2, varInsDef, fDefs)  {
					if (!writeFunctionDef)  return "";
					return tab1 + "// NN trained on " + trainingFileName + "\n" +
							tab1 + "// usage:  NNpredict(inputs, outputs) -- processes a single sample\n" +
							tab1 + "// * inputs[] has length " + layerSize[1] +
									"; outputs[] has length " + numOutputs + "\n\n" +
							"function NNpredict(ins" + varInsDef + ", outs)\n{\n" + "\n";
					return functionDef;		},
			
			MAT:  function(dummy, d2, d3, fDefs)  {
					return "% NN trained on " + trainingFileName + "\n\n" +
						"% usage:  'NN = myNN', then 'outputs = NN.predict(myNN, inputs)' to process a single sample\n" +
						"% * inputs is a length-" +  layerSize[1] +
								" column vector; outputs will have length " + numOutputs + "\n\n" +
					"classdef myNN < handle\nproperties\n\n" + tab1 + "ins\n" + tab1 + "outs\n";  },
			
			Py:  function(dummy, d2, d3, fDefs)  {
					return "import numpy as np\n\n\n" +
					tab1 + "# NN trained on " + trainingFileName + "\n" +
					tab1 + "# usage:  'outputs = myNN.predict(inputs)' to process a single sample\n" +
					tab1 + "# * inputs[] has length " +  layerSize[1] +
							"; outputs[] will have length " + numOutputs + "\n\n" +
					"class NNpredictor:\n" + tab1;  },
			
			R:  function(dummy, d2, d3, fDefs)  {
					return tab1 + "# NN trained on " + trainingFileName + "\n" +
					tab1 + "# usage:  'outputs = call NNpredict(inputs)' to process a single sample\n" +
					tab1 + "# * inputs[] has length " +  layerSize[1] +
							"; outputs[] will have length " + numOutputs + "\n\n" +
					"make.NN <- function()\n{";  }
		};
		
		const varDef = {
			C:  function(lName, lSize)
					{  return tab1 + Ctype + " " + lName + "[" + lSize + "];\n";  },
			Java:  function(lName, lSize)
					{  return tab1 + Ctype + "[] " + lName + " = new " + Ctype + "[" + lSize + "];\n";  },
			JS:  function(lName, lSize)
					{  return tab1 + "const " + lName + " = new Array(" + lSize + ");\n";  },
			MAT:  function(lName, lSize)
					{  return tab1 + lName + "\n";  },
			Py:  function(lName, lSize)
					{  return "";  },
			R:  function(lName, lSize)
					{  return "";  }
		};
		
		const weightsDef = {
			C:  function(wName, w, numRows, wType)
					{  return tab1 + "const static " + wType + " " + wName + "[] = { " + w + " };\n";  },
			Java:  function(wName, w, numRows, wType)
					{  return tab1 + "private static final " + wType + "[] " + wName + " = { " + w + " };\n";  },
			JS:  function(wName, w, numRows, wType)
					{  return tab1 + "const " + wName + " = [ " + w + " ];\n";  },
			MAT:  function(wName, w, numRows, wType)
					{  return tab1 + wName + " = [ " + w + " ];\n";  },
			Py:  function(wName, w, numRows, wType)
					{  return tab1 + wName + " = np.array([ " + w + " ])\n";  },
			R:  function(wName, w, numRows, wType)
					{  if (sparseWeights)  return tab1 + wName + " <- c(" + w + ")\n";
					   else  return tab1 + wName + " <- matrix(c(" + w + "), nrow = " + numRows + ", byrow = TRUE)\n";  }
		};
		
		const weightsDefLength = {
			C:  function()  {  return tab1.length + Ctype.length + 21;  },
			Java:  function()  {  return tab1.length + Ctype.length + 29;  },
			JS:  function()  {  return tab1.length + 11;  },
			MAT:  function()  {  return tab1.length + 5;  },
			Py:  function()  {  return tab1.length + 14;  },
			R:  function()  {  return tab1.length + 13;  }
		};
		
		const methodDef = {
			C:  function(dummy, d2, fDefs)
					{  return "";  },
			Java:  function(initLayerStr, varInsDef, fDefs)
					{  var a2lStr;
					if (!sparseWeights)  a2lStr = tab1 + "private void addToLayer(" +
								Ctype + "[] l, " + Ctype + "[] l0, " + Ctype + "[] w)\n" + tab1 + "{\n" +
							tab2 + "int i, i0, wIdx = 0;\n\n" +
							tab2 + "for (i = 0; i < l.length; i++)  {\n" +
							tab2 + "for (i0 = 0; i0 < l0.length; i0++)  {\n" +
							tab2 + "    l[i] += w[wIdx] * l0[i0];\n" +
							tab2 + "    wIdx++;\n" + tab2 + "}}\n" + tab1 + "}\n\n";
					else  a2lStr = tab1 + "private void addToLayer(" +
								Ctype + "[] l, " + Ctype + "[] l0, int[] n0, int[] nf, " + Ctype + "[] w)\n" + tab1 + "{\n" +
							tab2 + "int i;\n" +
							tab2 + "for (i = 0; i < w.length; i++)  {\n" +
							tab2 + "    l[nf[i]] += w[i] * l0[n0[i]];\n" + tab2 + "}\n" + tab1 + "}\n\n";
					return "\n" + tab1 + initLayerStr + a2lStr + fDefs + "\n" +
						tab1 + "public void predict(" + Ctype + "[] ins" + varInsDef + ", " +
							Ctype + "[] outs)\n" + tab1 + "{";  },
			JS:  function(initLayerStr, d2, fDefs)  {  var a2lStr;
					if (!sparseWeights)  a2lStr = tab1 + "function addToLayer(l, l0, w)\n" + tab1 + "{\n" +
						tab2 + "var n, n_0, idx = 0;\n\n" +
						tab2 + "for (n = 0; n < l.length; n++)  {\n" +
						tab2 + "for (n_0 = 0; n_0 < l0.length; n_0++)  {\n" +
						tab2 + "    l[n] += w[idx] * l0[n_0];\n" +
						tab2 + "    idx++;\n" + tab2 + "}}\n" + tab1 + "}\n\n";
					else  a2lStr = tab1 + "function addToLayer(l, l0, n0, nf, w)\n" + tab1 + "{\n" +
						tab2 + "var i;\n\n" +
						tab2 + "for (i = 0; i < w.length; i++)  {\n" +
						tab2 + "    l[nf[i]] += w[i] * l0[n0[i]];\n" +
						tab2 + "}\n" + tab1 + "}\n\n";
					return "\n" + tab1 + initLayerStr + a2lStr + fDefs;  },
			MAT:  function(dummy, varInsDef, fDefs)  {
					var varInsReshape = "", swFunctions = "";
					if (varInsDef.length > 0)  {
						varInsDef = ", varInsVec";
						varInsReshape = tab2 + "self.var_ins = reshape(varInsVec, [" + layerSize[variationalLayer] + ", 1]);\n";	}
					if (sparseWeights)  {
						if (!hasBias)  swFunctions = tab2 + "function v2 = clearLayer(n)\n" +
										tab3 + "v2 = zeros(1, n);\n" + tab2 + "end\n\n";
						if (hasBias)  swFunctions += tab2 + "function v2 = setLayer(idx, b, n)\n" +
										tab3 + "v2 = zeros(1, n);\n" + tab3 + "for i = 1:length(b)\n" +
												tab4 + "v2(idx(i)+1) = b(i);\n" + tab3 + "end\n" + tab2 + "end\n\n";
						swFunctions += tab2 + "function l = addToLayer(l, l0, n0, nf, w)\n" +
											tab3 + "for i = 1:length(w)\n" +
											tab4 + "l(nf(i)+1) = l(nf(i)+1) + w(i) * l0(n0(i)+1);\n" +
											tab3 + "end\n" + tab2 + "end\n\n";
					}
					return "end\n\nmethods\n\n" + tab1 + "function outputVec = predict(self, inputVec" + varInsDef + ")\n\n" +
							swFunctions + fDefs + tab2 +
							"self.ins = reshape(inputVec, [" +  layerSize[1] + ", 1]);\n" + varInsReshape;  },
			Py:  function(dummy, varInsDef, fDefs)  {
					var swFunctions = "";
					if (sparseWeights)  {
						swFunctions = tab2 + "def clearLayer(n):\n" + tab3 + "return [0] * n\n\n";
						if (hasBias)  swFunctions += tab2 + "def setLayer(idx, b, n):\n" +
										tab3 + "v2 = [0] * n\n" + tab3 + "for i in range(len(b)):\n" +
												tab4 + "v2[idx[i]] = b[i]\n" + tab3 + "return v2\n\n";
						swFunctions += tab2 + "def addToLayer(l, l0, n0, nf, w):\n" +
											tab3 + "for i in range(len(w)):\n" + tab4 + "l[nf[i]] = l[nf[i]] + w[i] * l0[n0[i]]\n\n";
					}
					return tab1 + "\n" + tab1 + "\n" + tab1 + "def predict(self, ins" + varInsDef + "):\n" +
							tab2 + "\n" + swFunctions + fDefs + tab2  + "ins = np.atleast_1d(ins)\n" + tab2;  },
			R:  function(dummy, varInsDef)  {
					var swFunctions = "";
					if (sparseWeights)  {
						swFunctions = tab1 + "clearLayer <- function(n)\n" + tab1 + "{\n" +
										tab2 + "return(numeric(n))\n" + tab1 + "}\n\n";
						if (hasBias)  swFunctions += tab1 + "setLayer <- function(idx, b, n)\n" + tab1 + "{\n" +
										tab2 + "v2 <- numeric(n)\n" + tab2 + "for (i in 1:length(b))  {\n" +
												tab3 + "v2[idx[i]+1] = b[i]\n" + tab2 + "}\n" + tab2 + "return(v2)\n" + tab1 + "}\n\n";
						swFunctions += tab1 + "addToLayer <- function(l, l0, n0, nf, w)\n" + tab1 + "{\n" +
											tab2 + "for (i in 1:length(w))  {\n" + tab3 + "l[nf[i]+1] = l[nf[i]+1] + w[i] * l0[n0[i]+1]\n" +
												tab2 + "}\n" + tab2 + "return(l)\n" + tab1 + "}\n\n";
					}
					return tab1 + "\n" + swFunctions + fDefs + tab1 + "NN.function <- function(ins" + varInsDef + ")\n" + tab1 + "{";  }
		};
		
		const clearLayer = {
			C:  function(lName, lSize, wName)
					{  return tab1 + "clearLayer(" + lName + ", " + lSize + ");\n";  },
			Java:  function(lName, lSize, wName)
					{  return tab2 + "clearLayer(" + lName + ");\n";  },
			JS:  function(lName, lSize, wName)
					{  return tab1 + "clearLayer(" + lName + ");\n";  },
			MAT:  function(lName, lSize, wName)  {
					if (!sparseWeights)  return tab2 + "self." + lName + " =";
					return tab2 + "self." + lName + " = clearLayer(" + lSize + ");\n";  },
			Py:  function(lName, lSize, wName)  {
					if (!sparseWeights)  return tab2 + lName + " =";
					return tab2 + lName + " = clearLayer(" + lSize + ")\n";  },
			R:  function(lName, lSize, wName)  {
					if (!sparseWeights)  return tab2 + lName + " <-";
					return tab2 + lName + " <- clearLayer(" + lSize + ")\n";  }
		};
		
		const setBias = {
			C:  function(lName, lSize, bName)
					{  return tab1 + "setLayer(" + lName + ", " + bName + ", " + lSize + ");\n";  },
			Java:  function(lName, lSize, bName)
					{  return tab2 + "setLayer(" + lName + ", " + bName + ");\n";  },
			JS:  function(lName, lSize, bName)
					{  return tab1 + "setLayer(" + lName + ", " + bName + ");\n";  },
			MAT:  function(lName, lSize, bName)
					{  return tab2 + "self." + lName + " = self." + bName;  },
			Py:  function(lName, lSize, bName)
					{  return tab2 + lName + " = self." + bName;  },
			R:  function(lName, lSize, bName)
					{  return tab2 + lName + " <- " + bName;  }
		};
		
		const setBiasSparse = {
			C:  function(lName, lSize, bIdxName, bName, bSize)
					{  return tab1 + "setLayer(" + lName + ", " + bIdxName + ", " + bName + ", " + lSize + ", " + bSize + ");\n";  },
			Java:  function(lName, lSize, bIdxName, bName, bSize)
					{  return tab2 + "setLayer(" + lName + ", " + bIdxName + ", " + bName + ");\n";  },
			JS:  function(lName, lSize, bIdxName, bName, bSize)
					{  return tab1 + "setLayer(" + lName + ", " + bIdxName + ", " + bName + ");\n";  },
			MAT:  function(lName, lSize, bIdxName, bName, bSize)
					{  return tab2 + "self." + lName + " = setLayer(self." + bIdxName + ", self." + bName + ", " + bSize + ");\n";  },
			Py:  function(lName, lSize, bIdxName, bName, bSize)
					{  return tab2 + lName + " = setLayer(self." + bIdxName + ", self." + bName + ", " + bSize + ")\n";  },
			R:  function(lName, lSize, bIdxName, bName, bSize)
					{  return tab2 + lName + " <- setLayer(" + bIdxName + ", " + bName + ", " + bSize + ")\n";  }
		};
		
		const addWeights = {
			C:  function(lName, lSize, l0Name, l0Size, wName, dummy)  {  return tab1 + "addToLayer(" +
					lName + ", " + lSize + ", " + l0Name  + ", " + l0Size + ", " + wName + ");\n";  },
			Java:  function(lName, lSize, l0Name, l0Size, wName, dummy)  {  return tab2 + "addToLayer(" +
					lName + ", " + l0Name + ", " + wName + ");\n";  },
			JS:  function(lName, lSize, l0Name, l0Size, wName, dummy)  {  return tab1 + "addToLayer(" +
					lName + ", " + l0Name + ", " + wName + ");\n";  },
			MAT:  function(lName, lSize, l0Name, l0Size, wName, plusStr)  {
					return plusStr + " self." + wName + "*self." + l0Name;  },
			Py:  function(lName, lSize, l0Name, l0Size, wName, plusStr)  {
					return plusStr + " np.matmul(self." + wName + ", " + l0Name + ")";  },
			R:  function(lName, lSize, l0Name, l0Size, wName, plusStr)  {
					return plusStr + " " + wName + "%*%" + l0Name;  }
		};
		
		const addWeightsSparse = {
			C:  function(lName, l0Name, n0Name, nfName, wName, Nw)  {  return tab1 + "addToLayer(" +
					lName + ", " + l0Name + ", " + n0Name  + ", " + nfName + ", " + wName + ", " + Nw + ");\n";  },
			Java:  function(lName, l0Name, n0Name, nfName, wName, Nw)  {  return tab2 + "addToLayer(" +
					lName + ", " + l0Name + ", " + n0Name  + ", " + nfName + ", " + wName + ");\n";  },
			JS:  function(lName, l0Name, n0Name, nfName, wName, Nw)  {  return tab1 + "addToLayer(" +
					lName + ", " + l0Name + ", " + n0Name  + ", " + nfName + ", " + wName + ");\n";  },
			MAT:  function(lName, l0Name, n0Name, nfName, wName, Nw)  {  return tab2 + "self." + lName + " = addToLayer(self." +
					lName + ", self." + l0Name + ", self." + n0Name  + ", self." + nfName + ", self." + wName + ");\n";  },
			Py:  function(lName, l0Name, n0Name, nfName, wName, Nw)  {  return tab2 + "addToLayer(" +
					lName + ", " + l0Name + ", self." + n0Name  + ", self." + nfName + ", self." + wName + ")\n";  },
			R:  function(lName, l0Name, n0Name, nfName, wName, Nw)  {  return tab2 + lName + " <- addToLayer(" +
					lName + ", " + l0Name + ", " + n0Name  + ", " + nfName + ", " + wName + ")\n";  }
		};
		
		const doF = {
			C:  function(AF, lName, lSize)  {  return tab1 + AFnames["C"][AF] + "(" + lName + ", " + lSize + ");\n";  },
			Java:  function(AF, lName, lSize)  {  return tab2 + AFnames["Java"][AF] + "(" + lName + ");\n";  },
			JS:  function(AF, lName, lSize)  {  return tab1 + AFnames["JS"][AF] + "(" + lName + ");\n";  },
			MAT:  function(AF, lName, lSize)  {  const endStrs = [ ";\n", "" ];
				return endStrs[swIdx] + tab2 + "self." + lName + " = " + AFnames["MAT"][AF] + "(self." + lName + ");\n";  },
			Py:  function(AF, lName, lSize)  {  const endStrs = [ "\n", "" ];
				return endStrs[swIdx] + tab2 + AFnames["Py"][AF] + "(" + lName + ")\n" + tab2;  },
			R:  function(AF, lName, lSize)  {    const endStrs = [ "\n", "" ];
				return endStrs[swIdx] + tab2 + lName + " <- " + AFnames["R"][AF] + "(" + lName + ")\n";  }
		};
		
		const footers = {
			C:  function (dummy)  {  return "}";  },
			Java:  function (dummy)  {  return tab1 + "}\n}";  },
			JS:  function(writeFunctionDef)  {  if (writeFunctionDef)  return "}";  else  return "";  },
			MAT:  function(writeFunctionDef)  {  const expEnds = [ ";\n", "" ];
					return expEnds[swIdx] + "\n" + tab2 + "outputVec = self.outs;\n" + tab1 + "end\nend\nend";  },
			Py:  function (dummy)  {  const expEnds = [ "\n", "" ];
					return expEnds[swIdx] + tab2 + "\n" + tab2 + "return outs\n\n\nmyNN = NNpredictor()";  },
			R:  function (dummy)  {  const expEnds = [ "\n", "" ];
					return expEnds[swIdx] + "\n" + tab2 + "return(outs)\n" + tab1 + "}\n\n" + tab1 +
						"return(NN.function)\n}\n\n\nNNpredict <- make.NN()";  }
		};
		
		function layerName(l)  {
			if (l == 1)  return "ins";
			else if (l == numLayers-1)  return "outs";
			else if (l == variationalLayer)  return "var_ins";
			else if ((variationalLayer > 1) && (l > variationalLayer))  return "hidden_" + (l-2).toString();
			else  return "hidden_" + (l-1).toString();
		}
		
		function layerShortName(l)
		{
			if (l == 0)  return "bias";
			else if (l == 1)  return "in";
			else if (l < numLayers-1)  return (l-1).toString();
			else  return "out";
		}
		
		function weightsName(l0, lf, arrayNum)
		{
			const arrayNames = [ "n0", "nf", "w" ];
			if (l0 == 0)  {
				if (arrayNum == 1)  return "nf_bias_" + layerShortName(lf);
				else  return "bias_" + layerShortName(lf);		}
			else  return arrayNames[arrayNum] + "_" + layerShortName(l0) + "_" + layerShortName(lf);
		}
		
		
		var initLayerStr = initLayerDef[NNlanguage]();
		var varInsDef = "";
		if (variationalLayer > 1)  varInsDef = ", " + varInputStr[NNlanguage]() + "var_ins";
		
		const numAFs = AFnames["JS"].length;
		const hasAF = new Array(numAFs).fill(false);
		for (cl = 2; cl < numLayers-1; cl++)  {
			hasAF[layerAFs[cl]] = true;
		}
		
		let fDefs = "";
		for (cAF = 1; cAF < numAFs; cAF++)  {
		if (hasAF[cAF])  {
			fDefs += AFfunctions[NNlanguage](cAF);
		}}
		
		var rtrn = headers[NNlanguage](writeFunctionDef, initLayerStr, varInsDef, fDefs);
		for (cl = 2; cl < numLayers-1; cl++)  {
		if (cl != variationalLayer)  {
			rtrn += varDef[NNlanguage](layerName(cl), layerSize[cl]);
		}}
		rtrn += "\n";
		
		var c3, c30;
		const wTypes = [ "int", "int", Ctype ];
		const wPrecisions = [ 0, 0, NNprecision ];
		
		if (!sparseWeights)  swIdx = 0;
		else  swIdx = 1;
		
		for (cl = 2; cl < numLayers; cl++)  {
		for (cil = 0; cil < numLayerInputs[cl]; cil++)  {
			let l0 = layerInputs[cl][cil];
			let wMatWidth = 0;
			let wMatRowSeparator = "";
			if (!sparseWeights)  {
				if (NNlanguage == "MAT")  {
					wMatWidth = layerSize[l0];
					wMatRowSeparator = "; "		}
				else if ((NNlanguage == "Py") && (l0 > 0))  {
					wMatWidth = layerSize[l0];
					wMatRowSeparator = "], ["		}
			}
			
			if (!sparseWeights)  c30 = 2;
			else if (l0 == 0)  c30 = 1;
			else  c30 = 0;
			for (c3 = c30; c3 < 3; c3++)  {
				let myName = weightsName(l0, cl, c3);
				var oneArray;
				if (c3 == 0)  oneArray = n0;
				else if (c3 == 1)  oneArray = nf;
				else  oneArray = weights;
				weightString = arrayStr(oneArray[cl][cil], wPrecisions[c3], wMatWidth, wMatRowSeparator,
						weightsDefLength[NNlanguage]() + myName.length, tab3, lineBreak[NNlanguage],
						(NNlanguage == "Java") && (precisionIdx == 0));
				if ((NNlanguage == "Py") && (l0 > 0) && (!sparseWeights))  weightString = "[" + weightString + "]";
				rtrn += weightsDef[NNlanguage](myName, weightString, layerSize[cl], wTypes[c3]);
			}
		}}
		
		rtrn += methodDef[NNlanguage](initLayerStr, varInsDef, fDefs)
		 
		for (cl = 2; cl < numLayers; cl++)  {
			let lName = layerName(cl);
			let lSize = layerSize[cl];
			let plusStr = "";
			let firstInputLayer = 0;
			
			if (cl != variationalLayer)  {
				if (layerInputs[cl][0] != 0)  {
					rtrn += "\n" + clearLayer[NNlanguage](lName, lSize, weightsName(0, cl, 2));	}
				else  {
					firstInputLayer = 1;
					if (!sparseWeights)  rtrn += "\n" + setBias[NNlanguage](lName, lSize, weightsName(0, cl, 2));
					else  rtrn += "\n" + setBiasSparse[NNlanguage](lName, lSize, 
							weightsName(0, cl, 1), weightsName(0, cl, 2), weights[cl][0].length.toString());
					plusStr = " +";
			}	}
			for (cil = firstInputLayer; cil < numLayerInputs[cl]; cil++)  {
				let l0 = layerInputs[cl][cil];
				if (!sparseWeights)  rtrn += addWeights[NNlanguage](lName, lSize,
								layerName(l0), layerSize[l0], weightsName(l0, cl, 2), plusStr);
				else  rtrn += addWeightsSparse[NNlanguage](lName, layerName(l0), weightsName(l0, cl, 0),
							weightsName(l0, cl, 1), weightsName(l0, cl, 2), weights[cl][cil].length.toString());
				plusStr = " +";
			}
			if (cl < numLayers-1)  {
			if (layerAFs[cl] != 0)  {
				rtrn += doF[NNlanguage](layerAFs[cl], lName, lSize);
		}	}}
		rtrn += footers[NNlanguage](writeFunctionDef);
		
		return rtrn;
	};
	
	
	
	function copyTable(source, dest)  {
		dest = [];
		for (var c1 = 0; c1 < source.length; c1++)  {
			var oneRow = [];
			for (var c2 = 0; c2 < source[c1].length; c2++)  oneRow.push(source[c1][c2]);
			dest.push(oneRow);
		}
	}
	
	
	
	function outputCode()  {
		document.getElementById("writeHeaders").disabled = true;
		document.getElementById("showInputs").disabled = true;
		
		document.getElementById("description").innerHTML = "Generating code..";
		language = document.getElementById("language").value;
		displayFileName = "myNN." + fileSuffix[language];
		tableNote = "";
		
		writeOutput("", NNcode(language, precision, true), 2);
		if ((canCheckPrediction) && (NNerrPrecision != precision))  {
			NNerrPrecision = precision;
			
			if (variationalLayer < 2)  costEstimator = new Function("ins", "outs", NNcode("JS", precision, false));
			else  costEstimator = new Function("ins", "var_ins", "outs", NNcode("JS", precision, false));
			NNinputs = trainingInputs;
			makeNNprediction(costEstimator);
			
			let dCost = calcCost(trainingOutputs, false, true);
			
			if (percentTestError >= 0)  {
				updateFractionalError("Est. prediction error ~",
						percentTestError, oneDig(percentTestError), dCost, oneDig(dCost), false);	}
			else  {
				updateFractionalError("Est. prediction error &gt; ~",
					percentTrainingError, oneDig(percentTrainingError), dCost, oneDig(dCost), false);
		}	}
	}
	
	
	
	function makeNNprediction(theNN)
	{
		NNoutputs = new Array(NNinputs.length);
		for (var cs = 0; cs < NNinputs.length; cs++)  {
			NNoutputs[cs] = new Array(numOutputs);
			NNoutputs[cs].fill(0);
			if (variationalLayer > 1)  theNN(NNinputs[cs], NNvariationalInputs[cs], NNoutputs[cs]);
			else  theNN(NNinputs[cs], NNoutputs[cs]);		}
	}
	
	function outputPrediction(doRecalc)
	{
		var IorO, ci, co, cio, cRow, numOutputRows;
		
		function getOutputRow(rowNum)  {
			var rtrn;
			
			if ((rowcol == 1) && (!showInputs))  rtrn = NNoutputs[rowNum];
			else  {
				rtrn = [];
				if (rowcol == 0)  {
				for (var cs = 0; cs < numSamples; cs++)  {
					if (!showInputs)  rtrn.push(NNoutputs[cs][rowNum]);
					else if (IorO[rowNum][0] == 1)  rtrn.push(NNinputs[cs][IorO[rowNum][1]]);
					else  rtrn.push(NNoutputs[cs][IorO[rowNum][1]]);
				}}
				else  {
				for (var cio = 0; cio < numIOs; cio++)  {
					if (IorO[cio][0] == 1)  rtrn.push(NNinputs[rowNum][IorO[cio][1]]);
					else  rtrn.push(NNoutputs[rowNum][IorO[cio][1]]);
			}	}}
			
			return rtrn;
		}
		
		if (doRecalc)  {
			document.getElementById("writeHeaders").disabled = false;
			if (!isAutoencoder)  document.getElementById("showInputs").disabled = false;
			
			displayFileName = fName.split(".")[0] + "_prediction.csv";
			
			if (variationalLayer >= 0)  {
				NNvariationalInputs = new Array(NNinputs.length);
				for (var cs = 0; cs < NNvariationalInputs.length; cs++)  {
					NNvariationalInputs[cs] = new Array(layerSize[variationalLayer]);
					for (var cn = 0; cn < layerSize[variationalLayer]; cn++)  {
						if (variationalDist == 1)  NNvariationalInputs[cs][cn] = Math.random();
						else  NNvariationalInputs[cs][cn] = grand();
			}	}	}
			
			if ((isDecoder) && (doExample))  {
				if (variationalLayer == 1)  NNinputs = NNvariationalInputs;
				else  {
					for (var cs = 0; cs < NNinputs.length; cs++)  {
					for (var cn = 0; cn < layerSize[1]; cn++)  {
						NNinputs[cs][cn] = grand();
			}	}	}}
			
			makeNNprediction(NNpredictor);
			
			if ((isDecoder) && (doExample))  {
				trueOutputs = NNoutputs;
		}	}		
		var NNoutputString = "";
		if ((writeHeaders) && (rowcol == 1))  {
			let charFromLeft = 0;
			if (showInputs)  {
			for (var cio = 0; cio < numIOs; cio++)  {
				if (cio > 0)  NNoutputString += separator;
				charFromLeft += separator.length;
				if ((wrapTo > 0) && (charFromLeft >= wrapTo))  {
					NNoutputString += "\n" + tab1;
					charFromLeft = tab1.length;		}
				NNoutputString += headersToWrite[cio];
				charFromLeft += headersToWrite[cio].length;
			}}
			else  {
			for (var co = 0; co < numOutputs; co++)  {
				if (co > 0)  NNoutputString += separator;
				charFromLeft += separator.length;
				if ((wrapTo > 0) && (charFromLeft >= wrapTo))  {
					NNoutputString += "\n" + tab1;
					charFromLeft = tab1.length;		}
				NNoutputString += headersToWrite[Oidx[co]];
				charFromLeft += headersToWrite[Oidx[co]].length;
			}}
			NNoutputString += "\n";
		}
		
		if (showInputs)  {
			IorO = [];
			for (cio = 0; cio < numIOs; cio++)  IorO.push(0);
			if (!isAutoencoder)  for (ci = 0; ci < numInputs; ci++)  IorO[Iidx[ci]] = [1,ci];
			for (co = 0; co < numOutputs; co++)  IorO[Oidx[co]] = [2,co];
			numOutputRows = numIOs;			}
		else  numOutputRows = numOutputs;
		if (rowcol == 1)  numOutputRows = numSamples;
		
		for (cRow = 0; cRow < numOutputRows; cRow++)  {
			if ((writeHeaders) && (rowcol == 0))  {
				if (showInputs)  NNoutputString += headersToWrite[cRow]+separator;
				else  NNoutputString += headersToWrite[Oidx[cRow]]+separator;		}
			NNoutputString += arrayStr(getOutputRow(cRow), precision, 0, "", 0, tab1, "", false) + "\n";
		}
		
		writeOutput("", NNoutputString, 1);
	}
	
	
	function refreshOutput()
	{
		if (whichAction == 1)  outputPrediction(false);
		else if (whichAction == 2)  outputCode();
	}
	
	
	
	function toHTML(theText)  {
		theText = theText.replace(/&/g, "&amp;");
		theText = theText.replace(/</g, "&lt;");
		theText = theText.replace(/>/g, "&gt;");
		theText = theText.replace(/"/g, "&quot;");
		return theText;
	}
	
	function writeDescription(explanation)  {
		let descriptor = "";
		if (displayFileName != "")  descriptor = "<TT>" + toHTML(displayFileName) + "</TT>";
		descriptor += toHTML(explanation);
		if (tableNote.length != 0)  descriptor += "*<br><font size=\"-1\">*" + toHTML(tableNote) + "</font>";
		if (dataWarning)  descriptor += "<p style=\"color:#FF0000\">" +
				"WARNING: training prediction seems off: bug? bad connection?</p>";
		document.getElementById("description").innerHTML = descriptor;
	}
	
	function writeOutput(explanation, toWrite, newWA)  {
		writeDescription(explanation);
		outputAsString = toWrite;
		document.getElementById("output").innerHTML = "<pre><code>" + toHTML(toWrite) + "</code></pre>";
		whichAction = newWA;
	}
	
	
	function setPrecision(newPrecision)  {
		precision = newPrecision;
		var precisionStr = "Floating point precision: &nbsp;" + precision + " digit";
		if (precision > 1)  precisionStr += "s";
		if (precision <= 8)  precisionIdx = 0;
		else  precisionIdx = 1;
		Ctype = Ctypes[precisionIdx];
		precisionStr += " (" + Ctype + ")";
		document.getElementById("digits").innerHTML = precisionStr;
	}
	
	function setCommaSpace(ifspace, doRefresh)
	{
		if (ifspace)  separator = ", ";
		else  separator = ",";
		if (doRefresh)  refreshOutput();
	}
	
	function setWrap(newWrap)
	{
		let newWrapTo = parseInt(newWrap, 10);
		if (isNaN(newWrapTo))  newWrapTo = 0;
		let doRefresh = (newWrapTo != wrapTo);
		wrapTo = newWrapTo;
		if (doRefresh)  refreshOutput();
	}
	
	function setWriteHeader(newWriteHeaders, doRefresh)
	{
		writeHeaders = newWriteHeaders;
		if (doRefresh)  refreshOutput();
	}
	
	function setIncludeInputs(newIncludeInputs, doRefresh)
	{
		showInputs = newIncludeInputs;
		if (doRefresh)  refreshOutput();
	}
	
	function oneDig(errPct)
	{
		return Math.max(1, Math.floor(Math.log10(errPct))+1);
	}
	
	function updateFractionalError(caption, errPct, numDigits, errPct2, numDigits2, firstTime)
	{
		var errQuote = errPct.toPrecision(numDigits) + "%";
		if (numDigits2 > 0)  errQuote += " + " + errPct2.toPrecision(numDigits2) + "%";
		if (firstTime)  errQuote += " of output variation";
		document.getElementById("relError").innerHTML = caption + errQuote;
	}
	
	function updateChecks()
	{
		document.getElementById("writeHeaders").checked = writeHeaders;
		if (isAutoencoder)  document.getElementById("showInputs").disabled = true;
		document.getElementById("showInputs").checked = showInputs;
	}
	
	
	function startUpload()
	{
		NNerrPrecision = 0;
		if (doExample)  doUpload(null);
		else  {
			document.getElementById("uploadLink").click();
			document.getElementById("uploadLink").value = null;		}
	}
	
	
	function doUpload(UL)
	{
		if (doExample)  fName = "random_data_test.csv";
		else  fName = UL.files[0].name;
		displayFileName = fName;
		writeDescription(" [processing]");
		
		if (doExample)  {
			rowHeaders = [];
			colHeaders = IOheaders;
			tableNums = testData;
			makePredictionFromTable();
		}
		else  {
			let reader = new FileReader();
			reader.onload = function() {
				if (parseCSV(reader.result) != 0)  return;
				makePredictionFromTable();
			}
			reader.readAsText(UL.files[0]);
		}
		
		initAxes();
		drawData();
	}
	
	
	function parseCSV(fileString)  {
		
		var cf;
		let hasRowHeader = false;
		let hasColumnHeader = false;
		const rows = fileString.split("\n");
		
		function writeOutputError(errText)
		{
			let lineNoFrom1 = lineNo+1;
			writeOutput(":  " + errText, "line " + lineNoFrom1 + ":  " + rows[lineNo], 0);
		}
		
		rowHeaders = [];
		colHeaders = [];
		tableNums = [];
		for (lineNo = 0; lineNo < rows.length; lineNo++)  {
			let fields = rows[lineNo].split(',');
			if (hasRowHeader)  {
				rowHeaders.push(fields[0]);
				fields = fields.slice(1, fields.length);	}
			
			if (fields.length > 0)  {
			if ((fields.length > 1) || (fields[0].length > 0))  {
				
				var numericFields = [];
				for (cf = 0; cf < fields.length; cf++)  numericFields.push(Number(fields[cf]));
				numericFields = numericFields.filter(el => !isNaN(el));
				
				if (lineNo == 0)  {
				if (numericFields.length < fields.length)  {
					if ((numericFields.length == fields.length-1) && (numericFields.length > 0))  {
					if (isNaN(Number(fields[0])))  {
						hasRowHeader = true;
						rowHeaders.push(fields[0]);
						fields = fields.slice(1, fields.length);
					}}
					else  {
						hasColumnHeader = true;
						colHeaders = fields;
				}}	}
				else if ((lineNo == 1) && (hasColumnHeader))  {
					if ((numericFields.length == fields.length-1) && (numericFields.length > 0))  {
					if (isNaN(Number(fields[0])))  {
						hasRowHeader = true;
						rowHeaders.push(fields[0]);
						fields = fields.slice(1, fields.length);
				}	}}
				
				if ((lineNo > 0) || (!hasColumnHeader))  {
					tableNums.push(numericFields);
					if (numericFields.length != fields.length)  {
						writeOutputError("non-numeric fields in sample file");
						return 1;			}
					if (fields.length != tableNums[0].length)  {
						writeOutputError("wrong number of fields in row");
						return 2;
				}	}
		}	}}
		if ((hasRowHeader) && (hasColumnHeader))  colHeaders = colHeaders.slice(1, colHeaders.length);
		
		return 0;
	}
	
	
	function makePredictionFromTable()
	{
		if (tableNums.length == 0)  return;
		
		let numRows = tableNums.length;
		let numCols = tableNums[0].length;
		let rowIOs = ((numRows == numInputs) || (numRows == numIOs));
		let colIOs = ((numCols == numInputs) || (numCols == numIOs));
		tableNote = "";
		
		var ci, co, cio, cs, tableHasSeparateTargetOuts;
		if ((rowIOs) && (colIOs))  {
			
			function compareArrays(a1, a2)  {
				if (a1.length == 0)  return false;
				if (a1.length != a2.length)  return false;
				for (var ci = 0; ci < a1.length; ci++)  if (a1[ci] != a2[ci])  return false;
				return true;
			}
			
			const inputHeaders = [];
			if (IOheaders.length > 0)  {
			for (var ci = 0; ci < Iidx.length; ci++)  {
				inputHeaders.push(IOheaders[Iidx[ci]]);
			}}
			
			rowcol = rowcol_train;
			tableNote = "? - check transpose";
			if (rowcol_train == 0)  {
				if ((compareArrays(rowHeaders, inputHeaders))
						|| (compareArrays(rowHeaders, IOheaders)))  {  rowcol = 0; tableNote = "";  }
				else if ((compareArrays(colHeaders, inputHeaders))
						|| (compareArrays(colHeaders, IOheaders)))  rowcol = 1;
			}
			else  {
				if ((compareArrays(colHeaders, inputHeaders))
						|| (compareArrays(colHeaders, IOheaders)))  {  rowcol = 1; tableNote = "";  }
				else if ((compareArrays(rowHeaders, inputHeaders))
						|| (compareArrays(rowHeaders, IOheaders)))  rowcol = 0;
			}
		}
		else if ((rowIOs) || (colIOs))  {
			if (rowIOs)  rowcol = 0;
			else  rowcol = 1;
		}
		else  {
			writeOutput(":  wrong number of input " + rowcolNames[rowcol_train] + "s", "", 0 );
			return;		}
		
		var doTransposed = (rowcol_train != rowcol);
		if (doTransposed)  tableNote = "transposed from training data";
		
		initHeaders();
		
		if (rowcol == 0)  {
			numSamples = numCols;
			tableHasSeparateTargetOuts = ((numRows == numIOs) && (!isAutoencoder));
			writeHeaders = ((IOheaders.length > 0) || (numRows == rowHeaders.length));
			if ((writeHeaders) && (IOheaders.length == 0))  {
				if (tableHasSeparateTargetOuts)  headersToWrite = rowHeaders;
				else for (ci = 0; ci < numInputs; ci++)  {
					headersToWrite[Iidx[ci]] = rowHeaders[ci];
		}	}	}
		else  {
			numSamples = numRows;
			tableHasSeparateTargetOuts = ((numCols == numIOs) && (!isAutoencoder));
			writeHeaders = ((IOheaders.length > 0) || (numCols == colHeaders.length));
			if ((writeHeaders) && (IOheaders.length == 0))  {
				if (tableHasSeparateTargetOuts)  headersToWrite = colHeaders;
				else for (ci = 0; ci < numInputs; ci++)  {
					headersToWrite[Iidx[ci]] = colHeaders[ci];
		}	}	}
		
		if ((!isDecoder) || (!doExample))  {
			if ((!tableHasSeparateTargetOuts) && (rowcol == 1))  NNinputs = tableNums;
			else  {
				NNinputs = [];
				trueOutputs = [];
				for (cs = 0; cs < numSamples; cs++)  {
					let oneSampleIns = [];
					let oneSampleOuts = [];
					for (ci = 0; ci < Iidx.length; ci++)  {
						if (!tableHasSeparateTargetOuts)  oneSampleIns.push(tableNums[ci][cs]);
						else if (rowcol == 0)  oneSampleIns.push(tableNums[Iidx[ci]][cs]);
						else  oneSampleIns.push(tableNums[cs][Iidx[ci]]);		}
					if (tableHasSeparateTargetOuts)  {
					for (co = 0; co < Oidx.length; co++)  {
						if (rowcol == 0)  oneSampleOuts.push(tableNums[Oidx[co]][cs]);
						else  oneSampleOuts.push(tableNums[cs][Oidx[co]]);		}}
					NNinputs.push(oneSampleIns);
					if (tableHasSeparateTargetOuts)  trueOutputs.push(oneSampleOuts);
		}	}	}
		
		showInputs = tableHasSeparateTargetOuts;
		updateChecks();
		outputPrediction(true);
		
		if (canCheckPrediction)  {
			if (tableHasSeparateTargetOuts)  {
				percentTestError = calcCost(trueOutputs, false, false);
				updateFractionalError("Test set prediction error: ",
						percentTestError, oneDig(percentTestError), 0, 0, false);	}
			else if (percentTestError >= 0)  {
				updateFractionalError("Est. prediction error ~",
						percentTestError, oneDig(percentTestError), 0, 0, false);	}
			else  {
				updateFractionalError("Est. prediction error &gt; ~",
						percentTrainingError, oneDig(percentTrainingError), 0, 0, false);	}
	}	}
	
	
	function initHeaders()
	{
		headersToWrite = [];
		if ((IOheaders.length == 0) || ((isAutoencoder) && (!hasDecoder)))  {
			for (var cio = 0; cio < numIOs; cio++)  headersToWrite.push("");
			if (!isAutoencoder)  for (var ci = 1; ci <= numInputs; ci++)  headersToWrite[Iidx[ci-1]] = "in_"+ci;
			if ((isAutoencoder) && (!hasDecoder))  {
				for (var co = 1; co <= numOutputs; co++)  headersToWrite[Oidx[co-1]] = "feature_"+co;  }
			else  {
				for (var co = 1; co <= numOutputs; co++)  headersToWrite[Oidx[co-1]] = "out_"+co;
		}	}
		else  {
		for (var cio = 0; cio < numIOs; cio++)  {
			headersToWrite.push(IOheaders[cio]);
		}}
	}
	
	
	function saveOutput()
	{
		const MIMEtypes = [ "text/csv", "text/plain" ];
		let myFile = new Blob([outputAsString], {type:MIMEtypes[whichAction-1]});
		if (window.navigator.msSaveOrOpenBlob)
			window.navigator.msSaveOrOpenBlob(myFile, displayFileName);
		else  {
			let tmpLink = document.createElement("a");
			tmpLink.href = URL.createObjectURL(myFile);
			tmpLink.download = displayFileName;
			
			document.body.appendChild(tmpLink);
			tmpLink.click();
			
			setTimeout(function() {  window.URL.revokeObjectURL(tmpLink.href),
						document.body.removeChild(tmpLink);  });
		}
	}
	
	
	function calcCost(targetOutputs, evalWarning, calcDiffErr)
	{
		var relError = 0;
		for (var co = 0; co < numOutputs; co++)  {
			var diffWithServer = 0, ySq = 0, yMean = 0, ySigma, trainingError = 0;
			
			for (var cs = 0; cs < NNoutputs.length; cs++)  {
				var oneDiff = NNoutputs[cs][co]-targetOutputs[cs][co];
				trainingError += oneDiff*oneDiff;
				ySq += targetOutputs[cs][co]*targetOutputs[cs][co];
				yMean += targetOutputs[cs][co];
				if ((evalWarning) || (calcDiffErr))  {
					var oneDiffWithServer = NNoutputs[cs][co]-outputCheck[cs][co];
					diffWithServer += oneDiffWithServer*oneDiffWithServer;
			}	}
			
			diffWithServer = Math.sqrt(diffWithServer / NNoutputs.length);
			trainingError = Math.sqrt(trainingError / NNoutputs.length);
			ySq /= NNoutputs.length;
			yMean /= NNoutputs.length;
			ySigma = Math.sqrt(ySq - yMean*yMean);
			
			if (ySigma > 0.)  {
				if (calcDiffErr)  relError += diffWithServer / ySigma;
				else  relError += trainingError / ySigma;		}
		
			if (evalWarning)  {
			if (ySq > 0.)  {
			if (!(diffWithServer/ySq < 1.e-8))  {
				dataWarning = true;
		}	}}}
		
		if (dataWarning)  refreshOutput();
		
		relError /= numOutputs;
		return 100*relError;
	}
	
	
	isDecoder = ((isAutoencoder) && (!hasEncoder));
	
	function setupWindow()  {
		document.getElementById("description").innerHTML = "Starting..";
		fName = trainingFileName;
		if (isAutoencoder)  numIOs = numOutputs;
		else  numIOs = numInputs+numOutputs;
		if (!isDecoder)  numSamples = trainingInputs.length;
		else  numSamples = trainingOutputs.length;
		rowcol = rowcol_train;
		initHeaders();
		writeHeaders = (IOheaders.length > 0);
		showInputs = !isAutoencoder;
		tableNote = "";
		updateChecks();
		writeRes();
		
		if (isDecoder)  {
			document.getElementById("centeredExpanderCaption").innerHTML = "Samples (x, y)";
			document.getElementById("xLabel").innerHTML = "output";
			document.getElementById("yLabel").innerHTML = "output";
			document.getElementById("zLabel").innerHTML = "Feature";
		}
		else  document.getElementById("centeredExpanderCaption").innerHTML = "Inputs (x, y) &rarr; output (color)";
		
		if (!isDecoder)  NNinputs = trainingInputs;
		else  {
			NNoutputs = trainingOutputs;
			NNinputs = new Array(numSamples);
			for (var cs = 0; cs < numSamples; cs++)  {
				NNinputs[cs] = new Array(layerSize[1]);
				NNinputs[cs].fill(0);
		}	}
		if ((!isAutoencoder) || (isDecoder))  trueOutputs = trainingOutputs;
		
		setPrecision(document.getElementById("precision").value);
		setCommaSpace(document.getElementById("numspaces").checked, true);
		document.getElementById("writeHeaders").checked = writeHeaders;
		
		if (variationalLayer < 2)  NNpredictor = new Function("ins", "outs", NNcode("JS", 16, false));
		else  NNpredictor = new Function("ins", "var_ins", "outs", NNcode("JS", 16, false));
		if (!isDecoder)  outputPrediction(true);
		else  document.getElementById("description").innerHTML = "No encoding loaded";
		
		initAxes();
		drawData();
		
		if (canCheckPrediction)  {
			percentTrainingError = calcCost(trainingOutputs, outputCheck.length > 0, false);
			updateFractionalError("Training set prediction error: ", percentTrainingError, 3, 0, 0, true);
	}	}
	
	</script>
	
	<style>
		div.leftButton {
			float:left;
			margin-left:0px;
			text-align:center;
			border-style:solid;
			border-width:10px;
			border-radius:4px;
			border-color:rgb(220,220,220);
			background-color:rgb(220,220,220);
		}
		div.rightButton {
			float:right;
			margin-right:30px;
			text-align:center;
			border-style:solid;
			border-width:10px;
			border-radius:4px;
			border-color:rgb(208,221,224);
			background-color:rgb(208,221,224)
		}
		div.centeredExpanderCaption {
			float: left;
			width: 300px;
			text-align: center;
			padding: 0 0 15px 0;
		}
		div.RHSexpanderButton {
			margin-left: 290px;
			cursor: pointer;
		}
		div.expander {
			max-height: 0;
			overflow: hidden;
			transition: max-height 0.2s ease-out;
		}
		div.plotOptionsBox {
			position: relative;
			width: 310px;
			line-height: 150%;
		}
		div.plotCol1 {
			position: relative;
			left: 10px;
			top: 0.5em;
			width: 135px;
		}
		div.plotCol2 {
			position: absolute;
			left: 155px;
			top: 0px;
			width: 155px;
		}
		div.plotCol2Inline {
			position: absolute;
			left: 155px;
			top: 0.5em;
			width: 155px;
		}
		div.thinLightBar {
			width:250px;
			height:1px;
			margin-left:30px;
			margin-top:10px;
			margin-bottom:10px;
			background-color:rgb(200,200,200);
		}
	</style>
</head>

<body style="user-select:none;-webkit-user-select:none" onload = setupWindow()>
	
	<div style="text-align:center;user-select:text;-webkit-user-select:text">
	<h2>NN trained on ##N##</h2>
	<h4>Generated ##D##</h4>
	</div><br>
	
	
	
	<div style="position:static;width:800px;margin:auto">
		
		<div style="width:800px;height:1px;margin:auto;background-color:rgb(67,67,67)"></div>
		<div style="width:800px;height:3px;margin:auto;background-color:rgb(0,146,179)"></div>
		<div style="width:800px;height:1px;margin:auto;background-color:rgb(67,67,67)"></div><br><br>
		
		<div style="width:750px;margin-left:25px;">
			<div style="float:left;width:430px;height:302px;margin-left:10px;text-align:left">
			<div style="position:relative;width:430px;height:302px">
				
				<div style="float:top;width:380px;height:200px;text-align:left">
					<font size="+1"><u>Instructions</u>:  <strong>Save this window as an HTML file</strong>
							or web archive for future use.  From here:
					
					<ul><li>Process a new table using the neural network##asterisk##;</li>
					<li>Export the neural network as computer code.</li></ul></font>
					##footnote##<br><br>
				</div>
				
				<div style="position:absolute;bottom:0px;width:420px;height:80px">
					<div class="leftButton">
						<label for="upload">&thinsp;&ensp;Process new samples&ensp;&thinsp;</label><br><br>
						<input type="file" id="uploadLink" name="uploadLink" style="display:none" onchange="doUpload(this)"></input>
						<button type="button" id="upload" name="upload" onclick="startUpload()">##UBtext##</button>
					</div>
					
					<div class="rightButton">
						<label for="language">Language: </label>
						<select name="language" id="language">
							<option value="C">C</option>
							<option value="Java">Java</option>
							<option value="JS">JavaScript</option>
							<option value="MAT">MATLAB</option>
							<option value="Py">Python</option>
							<option value="R">R</option>
						</select><br><br>
						<button type="button" id="makecode" name="makeCode" onclick="outputCode()">Generate code</button>
					</div>
				</div>
			</div></div>
			
			<div style="width:310px;top:0px;margin-left:440px;margin-top:0px">
				<p><canvas style="border:1px solid black;" id="plot" width="301" height="301"></canvas>
				<div class="centeredExpanderCaption" id="centeredExpanderCaption"></div></p>
				<div class="RHSexpanderButton" id="plotOptionsExpander">+</div><br>
				<div class="expander" id="plotOptions">
					<div class="plotOptionsBox">
						<div class="plotCol1">x:&ensp;<span id="xLabel">input</span> #
								<input type="text" id="xAxis" name="xAxis" size="4"></div>
						<div class="plotCol2">min <input type="text" id="xAxisMin" name="xAxisMin" size="10"><br>
								max <input type="text" id="xAxisMax" name="xAxisMax" size="10"></div><br>
					</div>
					<div class="plotOptionsBox">
						<div class="plotCol1">y:&ensp;<span id="yLabel">input</span> #
								<input type="text" id="yAxis" name="yAxis" size="4"></div>
						<div class="plotCol2">min <input type="text" id="yAxisMin" name="yAxisMin" size="10"><br>
								max <input type="text" id="yAxisMax" name="yAxisMax" size="10"></div><br>
					</div>
					<div class="plotOptionsBox">
						<div class="plotCol1"><span id="zLabel">&rarr; output</span> #
								<input type="text" id="zAxis" name="zAxis" size="4"></div>
						<div class="plotCol2">min <input type="text" id="zAxisMin" name="zAxisMin" size="10"><br>
								max <input type="text" id="zAxisMax" name="zAxisMax" size="10"></div><br>
					</div>
					<div class="thinLightBar"></div>
					<div style="text-align:center">
						Neural network overlay<br>
					</div>
					<div class="plotOptionsBox">
						<div class="plotCol1" id="resolutionReadout"></div>
						<div class="plotCol2Inline">
							<input type="range" min="1" max="7" style="width:80px;vertical-align:bottom;" value="7" id="resolution">
						</div>
					</div><br>
					<div class="plotOptionsBox">
						<small>&emsp;*Note: all non-x/y NN inputs are set to 0</small>
					</div><br>
				</div>
			</div>
		</div>
		
		<div style="width:800px;height:1px;margin:auto;background-color:rgb(67,67,67)"></div>
		<div style="width:800px;height:3px;margin:auto;background-color:rgb(0,146,179)"></div>
		<div style="width:800px;height:1px;margin:auto;background-color:rgb(67,67,67)"></div><br><br>
	</div><br><br>
	
	
	<div style="position:relative;width:550px;border:6px solid #F6F6F6;background-color:#F8F8F8">
	<div style="width:330px;margin-top:0.25lh;float:left">
	<div style="width:330px;margin-bottom:.4em" id="digits" name="digits"></div>
	<input type="range" id="precision" min="1" max="16" value="4"
			oninput="setPrecision(this.value)" onchange="refreshOutput()"><br>
	<div style="width:300px;margin-top:.6em" id="relError" name="relError"></div>
	</div>
	<div style="width:220px;margin-top:0.25lh;margin-left:330px">
	<input type="checkbox" id="writeHeaders" name="numspaces"
			onclick="setWriteHeader(this.checked, true)">
					<label for="writeHeaders">Write headers</label><br>
	<input type="checkbox" id="showInputs" name="showInputs" checked
			onclick="setIncludeInputs(this.checked, true)">
					<label for="showInputs">Show inputs</label><br>
	<div style="width:200px;height:1px;margin-top:3px;margin-bottom:3px;background-color:#B0B0B0"></div>
	<input type="checkbox" id="numspaces" name="numspaces" checked
			onclick="setCommaSpace(this.checked, true)">
					<label for="numspaces">Space after commas</label><br>
	Wrap lines to <input type="text" id="wrapTo" name="wrapTo"
			style="width:5em" onchange="setWrap(this.value)"> chars<br>
	</div>
	</div><br><br>
	
	
	<div style="width:100%;margin:0;padding:0">
	<div style="display:inline-block;width:450px;user-select:text;-webkit-user-select:text"
			id="description" name="Description"></div>
	<button type="button" value="Save" onclick="saveOutput()">Save to file</button><br>
	<div style="float:left;width:550px;height:2px;margin:auto;background-color:rgb(0,146,179)"></div><br>
	<div style="user-select:text;-webkit-user-select:text" id="output"></div>
	</div>
	

	<script type="text/javascript">
		
		function togglePlotOptions() {
			var optionBox = document.getElementById("plotOptions");
			var optionButton = document.getElementById("plotOptionsExpander");
			
			if (optionBox.style.maxHeight)  {
				optionBox.style.maxHeight = null;
				optionButton.innerHTML = "+";		}
			else  {
				optionBox.style.maxHeight = optionBox.scrollHeight + "px";
				optionButton.innerHTML = "&ndash;";		}
		}
		
		function getInt(fieldName)  {  return parseInt(document.getElementById(fieldName).value);  }
		function getFloat(fieldName)  {  return parseFloat(document.getElementById(fieldName).value);  }
		
		
		function colorOf(clr)  {  return "rgb(" + String(clr[0]) + "," + String(clr[1]) + "," + String(clr[2]) + ")";  }
		
		function drawData()  {
	
			const p = document.getElementById("plot");
			const c = p.getContext("2d");
			var clr = clrf = [0,0,0];
			const clrBack = [ 235, 235, 235 ];
			const clr0 = [ [ 220, 220, 220 ], [ 200, 200, 200 ] ];
			const clrPos = [ [ 255, 255, 0 ], [ 160, 0, 0 ] ];
			const clrNeg = [ [ 0, 255, 255 ], [ 0, 0, 160 ] ];
			const clrUnsup = [ [ 200, 100, 100 ], [ 200, 100, 100 ] ];
			
			c.fillStyle = colorOf(clrBack);
			c.fillRect(0, 0, 301, 301);
			
			let xAxis = getInt("xAxis")-1;
			let yAxis = getInt("yAxis")-1;
			let xMin = getFloat("xAxisMin");
			let xGridScale = getFloat("xAxisMax") - xMin;
			let xScale = 300 / xGridScale;
			let yMin = getFloat("yAxisMin");
			let yGridScale = getFloat("yAxisMax") - yMin;
			let yScale = 300 / yGridScale;
			let zAxis = getInt("zAxis")-1;
			let zMin = getFloat("zAxisMin");
			let zScale = 2. / (getFloat("zAxisMax") - zMin);
			let zGridScale = getFloat("zAxisMax") - zMin;
			
			var NNins = new Array(numInputs);
			var NNouts = new Array(numOutputs);
			NNins.fill(0.);
			NNouts.fill(0.);
			
			var variationalZeros = [];
			if (variationalLayer > 1)  {
				variationalZeros = new Array(layerSize[variationalLayer]);
				variationalZeros.fill(0);		}
			
			var x, y, z;
			if (!isDecoder)  {
				let NNres = (300 / imageRes()) + 1;
				var NNpredictionMap = c.createImageData(NNres, NNres);
				let idx = 0;
				for (let cy = 0; cy < NNres; cy++)  {
				for (let cx = 0; cx < NNres; cx++)  {
					NNins[xAxis] = xGridScale*(cx/(NNres-1)) + xMin;
					NNins[yAxis] = yGridScale*(cy/(NNres-1)) + yMin;
					if (variationalLayer > 1)  NNpredictor(NNins, variationalZeros, NNouts);
					else  NNpredictor(NNins, NNouts);
					
					z = 2 * (NNouts[zAxis]-zMin) / zGridScale - 1;
					if (z < -1.)  z = -1.;
					if (z > 1.)  z = 1.;
					
					if (z < 0.)  clrf = clrNeg[1];
					else  clrf = clrPos[1];
					for (let c3 = 0; c3 < 3; c3++)  {
						NNpredictionMap.data[idx+c3] = clr0[1][c3] + Math.abs(z)*(clrf[c3]-clr0[1][c3]);
					}
					NNpredictionMap.data[idx+3] = 255;
					idx += 4;
				}}
				c.putImageData(NNpredictionMap, 0, 0);
				c.drawImage(c.canvas, 0, 0, NNres, NNres, 0, 0, 301, 301);
			}
			
			var circleSource = NNinputs;
			if (isDecoder)  circleSource = NNoutputs;
			let circleSize = 40./Math.sqrt(numSamples);
			if (circleSize < 2)  circleSize = 2;
			for (let s = 0; s < numSamples; s++)  {
				x = xScale * (circleSource[s][xAxis]-xMin);
				y = yScale * (circleSource[s][yAxis]-yMin);
				if (!isAutoencoder)  {
					z = zScale * (trueOutputs[s][zAxis]-zMin) - 1.;
					if (z < -1.)  z = -1.;
					if (z > 1.)  z = 1.;
				}
				
				c.beginPath();
				c.arc(x, y, circleSize, 0, 2*Math.PI);
				if (!isAutoencoder)  {
					if (z < 0.)  clrf = clrNeg[0];
					else  clrf = clrPos[0];
					for (let c3 = 0; c3 < 3; c3++)  {
						clr[c3] = clr0[0][c3] + Math.abs(z)*(clrf[c3]-clr0[0][c3]);
				}	}
				else  clr = clrUnsup[0];
				c.fillStyle = colorOf(clr);
				c.fill();
				c.lineWidth = 0.5;
				c.strokeStyle = "black";
				c.stroke();
			}
			
			if (isDecoder)  {
				let zMax = getFloat("zAxisMax");
				let dz = lineRes() * (zMax - zMin);
				
				c.beginPath();
				for (z = zMin; z <= zMax; z += dz)  {
					NNins[zAxis] = z;
					if (variationalLayer > 1)  NNpredictor(NNins, variationalZeros, NNouts);
					else  NNpredictor(NNins, NNouts);
					
					x = xScale * (NNouts[xAxis]-xMin);
					y = yScale * (NNouts[yAxis]-yMin);
					
					if (z == -1.)  c.moveTo(x, y);
					else  c.lineTo(x, y);
				}
				c.lineWidth = 2;
				c.strokeStyle = "#222222";
				c.stroke();
			}
		}
		
		
		function setMinMax(masterArray, arrayIdx, minFieldName, maxFieldName, subtractR)  {
			var minField = document.getElementById(minFieldName);
			var maxField = document.getElementById(maxFieldName);
			
			if (masterArray.length == 0)  {
				minField.value = -1;
				maxField.value = 1;
				return;
			}
			
			let array = masterArray.map(function(oneSample) { return oneSample[arrayIdx]; });
			
			let minAxis = Math.min(...array);
			let maxAxis = Math.max(...array);
			
			if (minAxis == maxAxis)  {
				minField.value = -1;
				maxField.value = 1;
				return;
			}
			
			if (subtractR)  {
				let rCircle = (40/Math.sqrt(numSamples));
				let dMaxMin = rCircle*(maxAxis-minAxis) / (301-2*rCircle);
				minAxis -= dMaxMin;
				maxAxis += dMaxMin;
			}
			
			minField.value = minAxis.toPrecision(6);
			maxField.value = maxAxis.toPrecision(6);
		}
		
		
		function initAxes()  {
			document.getElementById("xAxis").value = "1";
			document.getElementById("yAxis").value = "2";
			document.getElementById("zAxis").value = "1";
			initXaxis();
			initYaxis();
			initZaxis();
		}
		
		function xyArray()  {  if (isDecoder)  return trueOutputs;  return NNinputs;  }
		function zArray()  {  if (isDecoder)  return NNinputs;  return trueOutputs;  }
		
		function initXaxis()  {  setMinMax(xyArray(), getInt("xAxis")-1, "xAxisMin", "xAxisMax", true);  }
		function initYaxis()  {  setMinMax(xyArray(), getInt("yAxis")-1, "yAxisMin", "yAxisMax", true);  }
		function initZaxis()  {  setMinMax(zArray(), getInt("zAxis")-1, "zAxisMin", "zAxisMax", false);  }
		function initXaxisAndPlot()  {  initXaxis(); drawData();  }
		function initYaxisAndPlot()  {  initYaxis(); drawData();  }
		function initZaxisAndPlot()  {  initZaxis(); drawData();  }
		
		resolution = document.getElementById("resolution");
		
		function imageRes()  {  vals = [1,2,3,4,5,6,10];  return vals[parseInt(resolution.value)-1];  }
		function lineRes()  {  vals = [.00001,.0002,.0004,.0001,.0002,.0004,.001];  return vals[parseInt(resolution.value)-1];  }
		
		function writeRes()  {
			var newstr = "Resolution: ";
			if (!isDecoder)  newstr += String(imageRes()) + " px";
			else  newstr += String(lineRes());
			document.getElementById("resolutionReadout").innerHTML = newstr;
		}
		
		document.getElementById("plotOptionsExpander").addEventListener("click", togglePlotOptions);
		
		document.getElementById("xAxis").addEventListener("change", initXaxisAndPlot);
		document.getElementById("xAxisMin").addEventListener("change", drawData);
		document.getElementById("xAxisMax").addEventListener("change", drawData);
		document.getElementById("yAxis").addEventListener("change", initYaxisAndPlot);
		document.getElementById("yAxisMin").addEventListener("change", drawData);
		document.getElementById("yAxisMax").addEventListener("change", drawData);
		document.getElementById("zAxis").addEventListener("change", initZaxisAndPlot);
		document.getElementById("zAxisMin").addEventListener("change", drawData);
		document.getElementById("zAxisMax").addEventListener("change", drawData);
		resolution.addEventListener("input", writeRes);
		resolution.addEventListener("change", drawData);
	
	</script>
	
</body>
</html>
